Abstract Factory
-----------------

Описание:
Интерфейс для создания семейств взаимосвязанных или взаимозависимых объектов
без специализации их конкретных классов

Когда использовать:
- система не должна зависеть от того, как создаются,
компонуются и представляются входящие в нее объектны
- входящие в семейство вза взаимосвязанные объекты должны использоваться вместе
и вам необходимо обеспечить выполнение этого ограничения
- система должна конфигурироваться одним из семейств составляющих ее объектов
- нужно предоставить библиотеку объектов,
раскрывая только их интерфейс, а не реализацию

Участники:
1) Абстактная Фабрика
- объявляет интерфейс для операций, создающих абстрактные объекты

2) Конкретная Фабрика
- реализует операции, создающие конкретные объекты

3) Абстрактный Продукт
- объявляет интерфейс для типа объекта-продукта

4) Конкретный продукт
- определяет объект-продукт, создаваемый соответствующей конкретной фабрикой
- реализует интерфейс Абстрактный Продукт

5) Клиенты
- пользуется интерфейсами объявленными исключительно
 в классах Абстрактной Фабрики и Абстактного Продукта

 Результаты
Паттерн абстрактная фабрика обладает следующими плюсами и минусами:
а изолирует конкретные классы. Помогает контролировать классы объектов,
создаваемых приложением. Поскольку фабрика инкапсулирует ответствен-
ность за создание классов и сам процесс их создания, то она изолирует
клиента от деталей реализации классов. Клиенты манипулируют экземпля-
рами через их абстрактные интерфейсы. Имена изготавливаемых классов из-
вестны только конкретной фабрике, в коде клиента они не упоминаются;
а упрощает замену семейств продуктов. Класс конкретной фабрики появля-
ется в приложении только один раз: при инстанцировании. Это облегчает за-
мену используемой приложением конкретной фабрики. Приложение может
изменить конфигурацию продуктов, просто подставив новую конкретную
фабрику. Поскольку абстрактная фабрика создает все семейство продуктов,
то и заменяется сразу все семейство. В нашем примере пользовательского
интерфейса перейти от виджетов Motif к виджетам Presentation Manager
можно, просто переключившись на продукты соответствующей фабрики
и заново создав интерфейс;
а гарантирует сочетаемость продуктов. Если продукты некоторого семей-
ства спроектированы для совместного использования, то важно, чтобы при-
ложение в каждый момент времени работало только с продуктами един-
ственного семейства. Класс AbstractFactory позволяет легко соблюсти
это ограничение;
а поддержать новый вид продуктов трудно. Расширение абстрактной фабри-
ки для изготовления новых видов продуктов - непростая задача. Интерфейс
AbstractFactory фиксирует набор продуктов, которые можно создать.
Для поддержки новых продуктов необходимо расширить интерфейс фаб-
рики, то есть изменить класс AbstractFactory и все его подклассы. Ре-
шение этой проблемы мы обсудим в разделе «Реализация».


Реализация
Вот некоторые полезные приемы реализации паттерна абстрактная фабрика:
а фабрики как объекты, существующие в единственном экземпляре. Как пра-
вило, приложению нужен только один экземпляр класса ConcreteFactory
на каждое семейство продуктов. Поэтому для реализации лучше всего при-
менить паттерн одиночка;
а создание продуктов. Класс AbstractFactory объявляет только интерфейс
для создания продуктов. Фактическое их создание - дело подклассов
ConcreteProduct. Чаще всего для этой цели определяется фабричный
метод для каждого продукта (см. паттерн фабричный метод). Конкретная
фабрика специфицирует свои продукты путем замещения фабричного ме-
тода для каждого из них. Хотя такая реализация проста, она требует созда-
вать новый подкласс конкретной фабрики для каждого семейства продук-
тов, даже если они почти ничем не отличаются.


class AbstractFactory(object):
    """определяет обязательный интерфейс для для Конкретных Фабрик"""
    def create_drink(self):
        raise NotImplementedError()

    def create_food(self):
        raise NotImplementedError()


class Drink(object):
    """Абстрактный продукт"""
    def __init__(self, name):
        self._name = name

    def __str__(self):
        return self._name


class Food(object):
    """Абстрактный продукт"""
    def __init__(self, name):
        self._name = name

    def __str__(self):
        return self._name


class ConcreteFactory1(AbstractFactory):
    """
    Конкретная Фабрика
    реализует интерфейс адстрактной фабрики
    """
    def create_drink(self):
        """Создает конкретный продукт"""
        return Drink('Coca-cola')

    def create_food(self):
        """Создает конкретный продукт"""
        return Food('Hamburger')


class ConcreteFactory2(AbstractFactory):
    """
    Конкретная Фабрика
    реализует интерфейс адстрактной фабрики
    """
    def create_drink(self):
        """Создает конкретный продукт"""
        return Drink('Pepsi')

    def create_food(self):
        """Создает конкретный продукт"""
        return Food('Cheeseburger')

if __name__ == '__main__':
    # Клиент

def get_factory(ident):
    if ident == 0:
        return ConcreteFactory1()
    elif ident == 1:
        return ConcreteFactory2()

factory = get_factory(1)
print factory.create_drink()  # Pepsi
print factory.create_food()  # Cheeseburger
