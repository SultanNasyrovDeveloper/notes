Design Pattern - модель решения частой архитектурной проблемы в программировании.
Паттерн описывает проблему и общий подход к решению этой проблемы.

Паттерны используются в разных отраслях не только в программировании.
Паттерны помогают не создавать кадый раз колесо, а использовать надежные, легкочитаемые, постоянные
и проверенные решения

Программируй на уровне интерефейсов а не реализаций

Интерфейсы в Python


Creational
deal with instantiation of objects
Отвечают за создание объектов
Structural
Deal with composition and other relation

Behavioral
Deal with responsibilities and communication between objects
Используется для управления операцией, действием, алгоритмом какого либо объекта

The Strategy(The Policy)
------------------------
Поведенческий паттерн

Основная цель этого шаблона - дать возможность клиентскому классу
выбирать между различными алгоритмами или
процедурами для выполнения одной и той же задачи.
Он отделяет клиентский класс от класса,
который фактически реализует детали алгоритма.

- семейство алгоритмов
- инкапсулирует в отдельный объект
- делает их взаимозаменяемыми

Задача:
- выбрать подходящий алгоритм по типу клиента или по типу обрабатываемых данных

Мотивы:
- программа должна обеспечивать различные варианты поведения
- использовать разные вариации одного алгоритма внутри объекта
- скрыть детали реализации алгоритмов
- много похожих классов отличающихся некоторым поведением
- нужно изменять поведения каждого экземпляра
- необходимо изменять поведение на стадии выполнени

Шаги:
- найти алгоритмы который подвержен частым изменениям
- или алгоритм имеющий много вариаций
- создать интерефейс стратегии общий для всех вариантов алгоритма
- создать поле для хранения ссылки на текущий объект-стратегию
а так же метод для изменения в контексте.
- клиенты контеста должны подавать в него существующий объект-стратегию




class People(object):
    """Абстрактный класс клиента"""
    tool = None

    def __init__(self, name):
	    self.name = name

    def setTool(self, tool):
	    self.tool = tool

    def write(self, text):
        """Использует интерефейс независимо от реализации"""
	    self.tool.write(self.name, text)

class ToolBase:
    """
    Семейство алгоритмов `Инструмент написания`
    """
    def write(self, name, text):
	    raise NotImplementedError()

class PenTool(ToolBase):
    """Ручка"""
    def write(self, name, text):
	    print u'%s (ручкой) %s' % (name, text)

class BrushTool(ToolBase):
    """Кисть"""
    def write(self, name, text):
	    print u'%s (кистью) %s' % (name, text)


class Student(People):
    """Студент"""
    tool = PenTool()

class Painter(People):
    """Художник"""
    tool = BrushTool()


maxim = Student(u'Максим')
maxim.write(u'Пишу лекцию о паттерне Стратегия')
# Максим (ручкой) Пишу лекцию о паттерне Стратегия

sasha = Painter(u'Саша')
sasha.write(u'Рисую иллюстрацию к паттерну Стратегия')
# Саша (кистью) Рисую иллюстрацию к паттерну Стратегия

# Саша решил стать студентом
sasha.setTool(PenTool())
sasha.write(u'Нет, уж лучше я напишу конспект')
# Саша (ручкой) Нет, уж лучше я напишу конспект



The Observer
------------
Поведенческий паттерн

Определяет зависимость типа один ко многим между объектами таким образом,
что при изменении состояния одного объекта все зависящие
от него оповещаются об этом событии
Cоздаёт механизм подписки, позволяющий одним объектам следить
и реагировать на события, происходящие в других объектах.

Задача:
-

Мотивы:
- отношение один ко многим, где один оповещает многих о своем изменении
- существует один объект расылающий сообщения
- одни объекты должны наблядать за другими, но только в определенных случаях
- имеется не менее одного получателя
- количетво и состав получателей может меняться во время работы приложения
- отправителя сообщений не интересует, что получатель сделает с информацией.

Шаги:
- Разделите функциональность на издателя и подписчиков
- создайте интерфейс подписчиков. Обычно достаточно опредлеить один метод оповещения
- создайте интерфейс издателя(оповещение всех подписчиков, добавление или удаление подписчика)
-


from abc import ABC, abstractmethod


class Observer(ABC):
    """
    Абстрактный наблюдатель
    """
    @abstractmethod
    def update(self, message: str) -> None:
        """
        Получение нового сообщения
        """
        pass

class Observable(metaclass=ABCMeta):
    """
    Абстрактный наблюдаемый
    """

    def __init__(self) -> None:
        """
        Constructor.
        """
        self._observers = set()    # инициализация списка наблюдателей

    def attach(self, observer: Observer) -> None:
        """
        Регистрация нового наблюдателя на подписку
        """
        self._observer.add(observer)

    def detach(self, observer: Observer):
        self._observers.remove(observer)

    def notify(self, message: str) -> None:
        """
        Передача сообщения всем наблюдателям, подписанным на события
        данного объекта наблюдаемого класса
        """
        for observer in self._observers:
            observer.update(message)

class Newspaper(Observable):
    """
    Газета, за новостями в которой следят тысячи людей
    """

    def add_news(self, news: str) -> None:
        """
        Выпуск очередной новости
        """
        self.notify(news)

class Citizen(Observer):
    """
    Обычный гражданин, который любит читнуть с утра любимую газетку
    """

    def __init__(self, name: str) -> None:
        """
        Constructor.

        :param name: имя гражданина, чтоб не спутать его с кем-то другим
        """
        self.name = name

    def update(self, message: str) -> None:
        """
        Получение очередной новости
        """
        print('{} узнал следующее: {}'.format(self.name, message))

if __name__ == '__main__':
    newspaper = Newspaper()                 # создаем небольшую газету
    newspaper.register(Citizen('Иван'))     # добавляем двух человек, которые
    newspaper.register(Citizen('Василий'))  # ... ее регулярно выписывают
    newspaper.add_news('Наблюдатель - поведенческий шаблон проектирования')



The Builder
-----------
Порождающий Паттерн

- отделяет конструированию сложных объектов от представления
- слишком много параметров
- инкапсулирует конструирование объекта
- выполняет конструирование в несколько шагов
- реализации могут меняться
- клиент видит только абстракцию


Фабричный метод
---------------
Порождающий паттерн

который определяет общий интерфейс для создания объектов в суперклассе,
позволяя подклассам изменять тип создаваемых объектов.

Применимость:
- заранее неизвестны типы создаваемых объектов
- когда хотите дать пользователям возможность расширять части вашей библиотеки
