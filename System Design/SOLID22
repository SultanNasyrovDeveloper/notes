 SOLID
-----

S - Single resposibility principle
O - Open/closed principle
L - Liskov substitution Principle
I - Interface segregation Principle
D - Dependency Inversion principle

Single Responsibility principle
--------------------------------
Принцип единственной ответственности.
Делай одну вещь но делай ее хорошо

Каждый объект должен иметь одну ответственность и эта ответственность
должна быть полностью инкапсулирована в класс. Все поведение класса
должно быть направлено полностью на обеспечение этой ответственности.

Когда мы проектируем класс постоянно должны задавать себе вопросы:
- насколько маленькой можно сделать эту фукнцию
- насколько коротким может быть этот класс

Код, который соблюдает этот принцип:
- намного легче читать
- он самодокументирован
- он ошибкоустойчивый
- легко тестируется

Когда использовать:
- при изменение кода в классе возникает потребность изменения в другом месте
- объекту позовлено слишком много

Open/closed Principle
-----------------------
Принцип открытости и закрытости.

Програмные сущности должны иметь возможность быть расширены
без необходимости быть измененными

Програмные сущности(модули, классы, фукнции) должны быть
- открыты для расширения: поведение сущности может быть расширено путем
создания новых типов сущностей.
- закрыты для изменения в результате расширения поведения сущности, не должны
вноситься изменения в код, который эти сущности использует

В течение 1990-х принцип открытости/закрытости стал де-факто переопределён
для применения с абстрактными интерфейсами, реализации которых
могут быть изменены, и могут быть созданы множественные реализации
и полиморфно замещены одна на другую.
В противоположность применения Мейером,
это определение поддерживает идею наследования от абстрактных базовых классов.
Спецификации интерфейсов могут быть переиспользованы через наследование,
но реализации изменяться не должны. Существующий интерфейс должен быть
закрыт для модификаций, а новые реализации должны, по меньшей мере,
реализовывать этот интерфейс.

Liskov Substitution Principle
-----------------------------
Прицип подстановки Лисков
Более простыми словами можно сказать, что поведение наследуемых классов
не должно противоречить поведению, заданному базовым классом,
то есть поведение наследуемых классов должно быть ожидаемым для кода,
использующего переменную базового типа.
подкласс не должен требовать от вызывающего кода больше, чем базовый класс,
и не должен предоставлять вызывающему коду меньше, чем базовый класс

Interface Segregation Principle
--------------------------------
Принцип разделения интерфейса.
Програмные сущности не должны зависеть от методов, которые они не используют.
При изменения метода интерфейса не должны меняться програмные сущности,
которые этот метод используют.

Dependency Inversion Principle
------------------------------
Модули верхних уровней не должны зависеть от модулей нижних уровней.
Оба типа модулей должны зависеть от абстракций.

Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.
